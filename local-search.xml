<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大数据安全</title>
    <link href="/2022/06/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    <url>/2022/06/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="大数据安全"><a href="#大数据安全" class="headerlink" title="大数据安全"></a>大数据安全</h1><h2 id="概念及目标"><a href="#概念及目标" class="headerlink" title="概念及目标"></a>概念及目标</h2><p>大数据安全：</p><ol><li>满足可用性的前提下实现大数据机密性和完整性</li><li>实现大数据的安全共享</li><li>实现大数据的真实性验证与可信溯源</li></ol><p>大数据隐私保护：</p><ol><li>由于去匿名化技术的发展，实现身份匿名越来越困难</li><li>基于大数据对人们状态和行为的预测带来隐私泄露威胁</li></ol><p>大数据安全与大数据隐私保护的区别与联系：</p><ol><li>大数据安全需求更加广泛，不仅包含数据机密性，还包括数据完整性、真实性、抗抵赖性等。而隐私保护需求一般仅聚焦于匿名性</li><li>虽然大数据隐私保护的匿名性看起来与大数据安全的机密性类似，但是后者显然严格得多，要求非授权用户完全不可访问</li><li>在大数据安全问题下，一般来说数据对象都是有明确定义的。而在涉及隐私保护时，用户的”隐私”较为笼统，可能具有多种数据形态存在</li></ol><p>数据生命周期：</p><ol><li>数据采集：一但真实数据被采集，用户隐私保护完全脱离用户自身控制</li><li>数据传输：保证数据在传输过程中内容不被恶意攻击者收集或破坏，有必要采取安全措施保证数据的机密性和完整性</li><li>数据存储：包括来自外部黑客的攻击、来自内部人员的信息窃取，还包括不同利益方对数据的超权限使用等</li><li>数据分析与使用：防止数据使用者对用户数据挖掘，得出用户刻意隐藏的知识；防止分析者在进行统计分析时，得到具体用户的隐私信息</li></ol><h2 id="访问控制技术"><a href="#访问控制技术" class="headerlink" title="访问控制技术"></a>访问控制技术</h2><h3 id="早期访问控制技术"><a href="#早期访问控制技术" class="headerlink" title="早期访问控制技术"></a><strong>早期访问控制技术</strong></h3><p>基本概念：</p><ul><li>访问控制：确保数据等资产只能经过授权的用户才能访问、使用和修改</li></ul><ul><li>主体：能够发起对资源的访问请求的主动实体，通常为系统的用户或进程</li><li>客体：能够被操作的实体，通常是各类系统和数据资源</li><li>操作：主体对客体的读、写等动作行为</li><li>访问权限：客体及对其的操作形成的二元组&lt;操作,客体&gt;</li><li>访问控制策略：对系统中主体访问客体的约束需求描述</li><li>访问（引用）授权：访问控制系统按照访问控制策略进行访问权限的赋予</li><li>引用监控机（Reference Monitor，RM）：指系统中监控主体和客体之间授权访问关系的部件</li></ul><h4 id="自主访问控制模型"><a href="#自主访问控制模型" class="headerlink" title="自主访问控制模型"></a><strong>自主访问控制模型</strong></h4><p>(S,O,A)： </p><ul><li><p>S：<code>subject</code> 主体集合</p></li><li><p>O：<code>object</code>  客体集合</p></li><li><p>A：访问矩阵，<br>$$<br>A(S_i,O_j) 表示主体S_i能够对客体O_j执行的操纵权限<br>$$</p></li></ul><p>A 的两种实现方式：</p><ol><li>能力表：基于主体，该表记录了每一个主体与一个权限集合的对应关系</li><li>访问控制列表：基于客体，该表记录了每一个客体与一个权限集合的对应关系</li></ol><p>缺点：</p><p>在大数据环境下，主体和客体数量巨大，无论哪种实现方式，自主访问控制模型都将面临权限管理复杂度爆炸式增长的问题。因此，直接采用自主访问控制模型是非常困难的</p><h4 id="强制访问控制模型"><a href="#强制访问控制模型" class="headerlink" title="强制访问控制模型"></a><strong>强制访问控制模型</strong></h4><p>其访问控制策略由安全管理员统一管理(<strong>基于格的访问控制模型</strong>)</p><p>安全管理员为系统中每个主客体分配安全标记，然后依据主客体安全标记之间的支配关系来进行访问控制。</p><h5 id="BLP模型-机密性"><a href="#BLP模型-机密性" class="headerlink" title="BLP模型(机密性)"></a><strong><code>BLP</code>模型(机密性)</strong></h5><p>核心规则是“<strong>不上读、不下写</strong>”，即<strong>低级别不能读取高级别的数据</strong>，<strong>高级别不能修改低级别的数据</strong>，保证数据只能从低级别往高级别流动</p><ol><li>安全级别Level：公开（UC）、秘密（S）、机密（C）、绝密（TS）。它们之间的关系为UC≤S≤C≤TS。 </li><li>范畴Category：为一个类别信息构成的集合，例如｛中国，军 事，科技｝。具有该范畴的主体能够访问那些以该范畴子集为范畴的客体。 </li><li>安全标记Label：由安全级别和范畴构成的二元组&lt;Level，Category&gt;，例如&lt;C,｛中国,科技｝&gt;。 </li><li>支配关系dom：安全标记A dom B，当且仅当LevelA ≥ LevelB，CategoryA ⊇ CategoryB。A dom B 表示A的级别比B高</li></ol><p>BLP模型中在为系统中每个保护范围内的主客体都分配了安全标记后，主体对客体的访问行为应满足如下两条安全属性：</p><ol><li>简单安全属性：主体S可以读客体O，当且仅当LabelS dom LabelO，且S对O有自主型读访问权限。(S级别比O高，可以向下读，即S读O)</li><li>安全属性：主体S可以写客体O，当且仅当LabelO dom LabelS，且S对O具有自主型写权限。(O级别比S高，可以向上写，即S写O)</li></ol><p>不上读，不下写。也就是说，等级高的能读等级低的，等级低的能写等级高的。</p><p>阻止了信息从高安全级别流入低安全级别，且使得信息“仅被需要知悉的人所知悉”，因此，能够有效地确保数据的机密性</p><h5 id="Biba模型-完整性"><a href="#Biba模型-完整性" class="headerlink" title="Biba模型(完整性)"></a><strong><code>Biba</code>模型(完整性)</strong></h5><p>Biba模型是第一个关注完整性的访问控制模型，用于防止用户或应用程序等主体未授权地修改重要的数据或程序等客体。该模型可以看作是BLP模型的对偶</p><ol><li>完整性级别Level：代表了主/客体的可信度。完整性级别高的主体比完整性级别低的主体在行为上具有更高的可靠性；完整性级别高的客体比完整性级别低的客体所承载的信息更加精确和可靠</li><li>范畴Category：若范畴CategoryA ⊇ CategoryB</li><li>完整性标记Label：由完整性级别和范畴构成的二元组&lt;Level，Category&gt;</li><li>支配关系dom：完整性标记A dom B，当且仅当LevelA ≥ LevelB ，CategoryA ⊇ CategoryB</li></ol><p>完整性代表可信度。可信度与其范畴决定支配等级，决定读写关系，高写低读</p><ol><li>完整性特性：主体S能够写入客体O，当且仅当LabelS dom LabelO。</li><li>调用特性：主体S1能够调用主体S2，当且仅当LabelS1 dom LabelS2。 </li><li>简单完整性条件：主体S能够读取客体O，当且仅当LabelO dom LabelS。</li></ol><p>高完整性能写低完整性，低完整性能读高完整性</p><p>信息只能从高完整性级别的主客体流向低完整性级别的主客体，从而有效避免了低完整性级别的主客体对高安全级别主客体的完整性的“污染”</p><p>缺点：</p><ul><li>随着主客体规模的急剧增长，安全标记的定义和管理将变得非常繁琐</li><li>来自多个应用的用户主体和数据客体也将使得安全标记难以统一</li></ul><h4 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a><strong>基于角色的访问控制</strong></h4><p><img src="https://s2.loli.net/2022/06/04/USV8rtyR735qbMg.png" alt="image-20220604142804180"></p><p><img src="https://s2.loli.net/2022/06/04/qMUElIi7kcY6NRB.png" alt="image-20220604142828162"></p><h4 id="基于属性的访问控制"><a href="#基于属性的访问控制" class="headerlink" title="基于属性的访问控制"></a><strong>基于属性的访问控制</strong></h4><p><img src="https://s2.loli.net/2022/06/04/xX3yhmCbclMtNOZ.png" alt="image-20220604143407686"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><img src="https://s2.loli.net/2022/06/04/KOFvaLJYqWbXgjc.png" alt="image-20220604143526461"></p><h3 id="风险自适应的访问控制技术"><a href="#风险自适应的访问控制技术" class="headerlink" title="风险自适应的访问控制技术"></a><strong>风险自适应的访问控制技术</strong></h3><p>风险量化：</p><ol><li>基于概率论的风险量化：风险量化值由危害发生的可能性和危害程度决定</li><li>基于协同过滤的动态风险量化：通过<strong>行为异常</strong>的概率来衡量风险值，所以风险量化结果可以随着系统中整体用户的行为变化而动态变化，相比于静态计算方法更加灵活。然而这种计算往往需要大量的系统历史数据以确保风险量化的准确性</li></ol><p>实现整个系统风险与收益平衡的方法包括：</p><ol><li>信用卡式：它为每个用户分配风险额度，并让用户在访问资源时根据访问带来的风险去消耗额度。当额度不足以支付新的访问时，系统将阻止用户的访问行为。</li><li>市场交易式：它将风险视为市场上的商品，而整个系统能够容忍的风险被视为可以交易的商品总量。作为商品的风险流通越充分，则越能够实现整体系统的风险与收益的最优化配置。</li></ol><p>风险访问控制通常采用与传统访问控制结合的实施框架。</p><h3 id="基于密码学的访问控制技术"><a href="#基于密码学的访问控制技术" class="headerlink" title="基于密码学的访问控制技术"></a><strong>基于密码学的访问控制技术</strong></h3><p>依赖于密钥的安全性，不需要可信引用监控机，有效解决大数据安全的问题：</p><ol><li>大数据分析架构，很难建立可信引用监控机</li><li>大数据场景下，数据经常处于所有者控制范围之外</li></ol><h4 id="基于密钥管理的访问控制技术"><a href="#基于密钥管理的访问控制技术" class="headerlink" title="基于密钥管理的访问控制技术"></a><strong>基于密钥管理的访问控制技术</strong></h4><p><strong>基于单发送者广播加密的访问控制</strong>：</p><p><img src="https://s2.loli.net/2022/06/04/86lCQztHaAk5Tip.png"></p><p><strong>基于公钥广播加密的访问控制</strong>：</p><ul><li>公钥服务器：负责维护一个密钥集合。即将系统中的所有用户划分为子集，每个子集代表了可能的数据接收者集合。为每个子集产生公私钥对，并将私钥安全分发给其包含的用户</li><li>数据所有者：负责将数据加密，并采用基于公钥广播加密技术对加密密钥进行分发，以实现对授权接收者的限定</li><li>数据服务者：负责加密数据的存储，并向用户提供对数据的操作</li><li>用户：是数据的访问者。只有被数据所有者授权的用户才能获得数据的加密密钥，并进一步解密出数据</li></ul><p>由于采用公钥加密方式，所以系统的所有用户都可以是数据所有者，并向其他用户分享数据，消除了单发送者广播加密方案对发送者范围的限制</p><h4 id="基于属性加密的访问控制"><a href="#基于属性加密的访问控制" class="headerlink" title="基于属性加密的访问控制"></a><strong>基于属性加密的访问控制</strong></h4><p>在基于密钥管理的访问控制中，系统通过控制用户持有的密钥集合来区分用户，进而实施授权和访问控制</p><p>基于属性加密的访问控制是通过更加灵活的属性管理来实现访问控制，即将<strong>属性集合</strong>作为公钥进行数据加密，要求只有满足该属性集合的用户才能解密数据</p><h2 id="角色挖掘算法-会算"><a href="#角色挖掘算法-会算" class="headerlink" title="角色挖掘算法(会算)"></a>角色挖掘算法(会算)</h2><p>基本定义：</p><ul><li>类簇Cluster：由权限和持有这些权限的用户组成的二元组c=&lt;rights，members&gt;</li><li>用户集合Persons：所有用户组成的集合</li><li>类簇集合Clusters：包含所有类簇的聚类结果集</li><li>偏序关系集合&lt;：聚类之间的偏序关系构成的集合</li><li>无偏序关系类簇集合T&lt;：类簇集合中的类簇，两两间不存在偏序关系。</li></ul><p><img src="https://s2.loli.net/2022/06/04/AtCfLXyiR2QsTv8.png" alt="image-20220604152948719"></p><p>基于层次聚类的角色挖掘存在的问题：</p><p>它们是对已有的权限分配数据进行角色挖掘，所以挖掘出的角色定义的质量往往过多地依赖于已有权限分配的质量。而对于大数据应用这种复杂场景来说，已有权限分配的质量往往很难保证。</p><h2 id="对称-非对称加密，hash算法"><a href="#对称-非对称加密，hash算法" class="headerlink" title="对称 | 非对称加密，hash算法"></a>对称 | 非对称加密，hash算法</h2><p>信息学四大问题：</p><ol><li><p>身份认证：“ 我是谁？”</p><p>解决方法：密码技术</p></li><li><p>信息机密性：信息泄密问题</p><p>解决方法：加密</p></li><li><p>信息完整性：信息被恶意篡改问题</p><p>解决方法：数字摘要</p></li><li><p>抗抵赖性：抵赖和责任认定问题</p><p>解决方法：数字签名</p></li></ol><p><img src="https://s2.loli.net/2022/06/05/NUaqXTZGjiR7ICW.png" alt="image-20220605113737398"></p><p>密码学组成体系：</p><p><img src="https://s2.loli.net/2022/06/05/wP2E8MQ4y3AOXVF.png" alt="image-20220605114203563"></p><p>密钥算法：</p><p><img src="https://s2.loli.net/2022/06/04/bz6waeL7G1vlEqj.png" alt="image-20220604215658543"></p><p>公钥密码与对称密码的比较：</p><ol><li><p>密钥的分配和管理</p><p>在对称密码中，双方使用同一密钥进行加密和解密，所以，密钥的分配和管理困难。密钥数量大，n 个用户之间相互通信，需要n(n-1)/2个密钥。 在公钥密码中，用户使用一对密钥：公钥和私钥，公钥可以公开，私钥必须保密。因而，密钥的分发十分方便。密钥数量小，n 个用户之间相互通信，需要 n 个密钥对。</p></li><li><p>数字签名功能</p><p>对称密码不能提供不可否认的数字签名功能，公钥密码的优点是可以提供不可否认的数字签名。</p></li><li><p>实际使用</p><p>对称密码算法速度快，适合加密大批量数据；公钥密码算法速度慢，适合完成对称密码算法的密钥分配以及数字签名、身份鉴别等各种密码协议。</p></li></ol><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密和解密使用相同的密钥</p><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p><strong>每次加密一组</strong></p><p>设计原则：</p><ol><li>分组长度n要足够大，防止明文穷举攻击</li><li>密钥长度要足够大，防止密钥穷举攻击</li><li>非线性运算等复杂运算部件，密钥与明文充分混淆(Confusion)和扩散(Diffusion)，雪崩效应</li></ol><p><img src="https://s2.loli.net/2022/06/05/jUmH2W3ADcupxSb.png" alt="image-20220605115904880"></p><p>替换操作：S-Box —— 最左比特与最右比特合成行号，中间4比特为列号，查表替换为4比特块</p><p>置换操作：P —— 将该位置比特与放置于指定位置</p><p>扩展操作：E —— 分别将第i-1块的最右比特和第i+1块的最左比特添到第i块的左边和右边,形成输出的第i个6比特块</p><h5 id="DES"><a href="#DES" class="headerlink" title="DES"></a><strong>DES</strong></h5><p><strong>明文和密文为64比特长度</strong>，加密和解密使用同一算法</p><p>密钥长度：实际有效密钥长度为56比特，每个字节的第8位为奇偶校验位</p><p>以下是一轮的操作：</p><p><img src="https://s2.loli.net/2022/06/05/mr4628kwT9JRpe3.png" alt="image-20220605120849975"></p><p>流程： R ——&gt;  E ——&gt; XOR K ——&gt; S-Box ——&gt; P ——&gt; XOR L ——&gt; R NEXT</p><p>​            R ——&gt; L NEXT</p><h5 id="AES"><a href="#AES" class="headerlink" title="AES"></a><strong>AES</strong></h5><p>明文分组与密钥纵向排列成阵列</p><p>流程：</p><ol><li>字节替代 (sub)：S-Box 替换</li><li>行位移(shr)：循环左移，第i行左移i个单位</li><li>列混淆(mic)：</li><li>轮密钥加(ark)：XOR K</li></ol><h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a><strong>工作模式</strong></h5><h6 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a><strong>ECB</strong></h6><p>直接加密明文分组</p><p>优点：简单高效，可以实现并行操作</p><p>缺点：相同的分组，密文也是相同的</p><h6 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a><strong>CBC</strong></h6><p>优点：安全性高</p><p>缺点：加密不能并行，解密可以并行</p><p>有 VI，先 XOR，再加密，密文与下一轮的明文 XOR</p><h3 id="密码杂凑算法"><a href="#密码杂凑算法" class="headerlink" title="密码杂凑算法"></a><strong>密码杂凑算法</strong></h3><p><strong>用途：数据完整性、消息鉴别码、数字签名、基于口令的身份认证</strong></p><p><strong>单向性</strong>： 给定h，找到x使h=H(x)在计算上不可行(逆运算不可行)</p><p><strong>抗弱碰撞性</strong>：给定x，找到y，x使H(x)=H(y)在计算上不可行</p><p><strong>抗强碰撞性</strong>：找到x和y，使H(x)=H(y)在计算上不可行</p><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a><strong><code>MD5</code></strong></h4><p><img src="https://s2.loli.net/2022/06/05/l1v7iumSsxMarHk.png" alt="image-20220605135939923"></p><h4 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a><code>SM3</code></h4><h4 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a><strong><code>MAC</code></strong></h4><p>消息鉴别码(认证码)</p><p>通信双方A和B共享一密钥K</p><p>作用：验证接收消息的<strong>真实性</strong>（的确是由它所声称的实体发来的）<strong>和完整性</strong>（未被篡改、插入、删除）</p><p>用K来加密数据作为认证码，将认证码与数据一起发送给对方，对方用K解密认证码后如果与数据保持一致，说明发送方身份是正确的(拥有正确的密钥)，而且数据是完整的(认证码与数据对应)</p><p><strong><code>HMAC</code></strong></p><p>基于HASH算法的、带密钥的消息鉴别码</p><h4 id="FIPS"><a href="#FIPS" class="headerlink" title="FIPS"></a><strong><code>FIPS</code></strong></h4><p>算法基于CBC模式的DES算法，其初始向量取为零向量</p><h3 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h3><p>为什么需要公钥密码算法？——对称密码的不足：</p><ol><li>密钥分配/协商问题：通信双方要用对称密码进行加密通信，需要通过秘密的安全信道协商对称密钥，而这种安全信道可能很难实现</li><li>密钥管理问题：在有很多用户的网络中，任何两个用户之间都需要有共享的对称密钥，当网络中的用户n很大时，需要管理的密钥数目非常大，即n(n-1)/2</li><li>数字签名和身份鉴别功能：当主体A收到主体B的电子文挡（电子数据）时，对称密码无法向第三方证明此电子文档确实来源于B</li></ol><p>:raised_hand: 辗转相除法求最大公约数</p><p>:raised_hand: 辗转相除法求逆元</p><p><img src="https://s2.loli.net/2022/06/05/6UeRyCSdBZw8F1c.png" alt="image-20220605144117497"></p><p><strong>注意</strong>：</p><ul><li>商数不算最后一个</li><li>起始项都为1，第1项为商数1，后续项为 前2项 + 前1项 * 本项对应商数</li></ul><p>求欧拉函数：</p><p><img src="https://s2.loli.net/2022/06/05/W18tOAQGlyjaEKL.png" alt="image-20220605144806010"></p><p>因式分解，注意<strong>对于幂次，只取其中一个变成 -1</strong></p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a><strong><code>RSA</code></strong></h4><p><img src="https://s2.loli.net/2022/06/05/e7qkJSuj15axMXI.png" alt="image-20220605145919642"></p><h2 id="密文索引"><a href="#密文索引" class="headerlink" title="密文索引"></a>密文索引</h2><p>密文检索（Searchable Encryption，SE）技术支持云存储系统在密文场景下对用户数据进行检索，然后将满足检索条件的密文数据返回给用户</p><p>在检索过程中，云服务器无法获得用户的敏感数据和查询条件，即密文检索可以同时保护数据机密性以及查询机密性</p><p>系统流程：</p><ol><li>数据所有者首先为数据构造支持检索功能的索引，同时使用传统的加密技术加密全部数据，然后将密文数据<br>和索引共同存储到服务器。(存加密后数据和索引)</li><li>需要检索时，数据检索者为检索条件生成相应的<strong>陷门</strong>，并发送给服务器。(加密后的检索条件)</li><li>服务器使用索引和陷门进行协议预设的运算，并将满足检索条件的密文数据返回给数据检索者。</li><li>数据检索者使用密钥将检索结果解密，得到明文数据。有时服务器返回的密文数据中可能包含不满足检索条件的冗余数据，此时数据检索者还需要对解密后的明文数据进行二次检索，即在本地剔除冗余数据。</li></ol><p><strong>密文检索分类</strong></p><p>根据应用场景的不同：</p><ol><li>对称密文检索：数据所有者和数据检索者为同一人(自己拥有自己搜索)</li><li>非对称密文检索：在非对称密钥环境下，任何可以获得数据检索者公钥的用户都可以提交敏感数据，但只有拥有私钥的数据检索者可以生成陷门。(有公钥的是数据所有者，可以上传数据；有私钥的是数据检索者，可以生成陷门，检索数据)</li></ol><p>根据检索的数据类型的不同：</p><ol><li>关键词检索：字符型/文本型数据。关键词检索的研究以<strong>单关键词检索</strong>为主，后来逐渐扩展到<strong>多关键词检索</strong>、<strong>模糊检索</strong>以及<strong>Top-k检索</strong></li><li>区间检索：数值型数据。<strong>单维区间检索</strong>和<strong>多维区间检索</strong></li></ol><h3 id="早期安全检索技术"><a href="#早期安全检索技术" class="headerlink" title="早期安全检索技术"></a>早期安全检索技术</h3><h4 id="PIR技术"><a href="#PIR技术" class="headerlink" title="PIR技术"></a><strong><code>PIR</code>技术</strong></h4><p>主要针对<strong>公开数据库</strong>，目标是允许用户在<strong>不向服务器暴露查询意图</strong>的前提下，对服务器中的数据进行查询并取得指定内容(不信任服务器)</p><p><img src="https://s2.loli.net/2022/06/04/siEzQ68XUhR74nL.png" alt="image-20220604200709986"></p><p>查询拆分</p><p><strong><code>PIRK</code>技术</strong></p><p>设存在𝑘个服务器，其存储的内容完全相同，均为𝑛个长度为𝑙的字符串𝑆 = {𝑠1, 𝑠2, … , 𝑠𝑛}，且服务器之间不会进行相互通信。A感兴趣的关键词是一个长度为𝑙的字符串𝑤</p><p>如果存在一个协议使A能够得到所有满足𝑠𝑗 = 𝑤的𝑗 ，且任意服务器均不了解关于𝑤的任何信息，则称该协议是𝑃𝐼𝑅𝐾(𝑙, 𝑛, 𝑘)的</p><p>这里只需要通过 <code>PIRK</code> 找到关键词 𝑤 在服务器中对应的位置(可能不止一个)，至于怎么把关键词相关的内容提取出来，还是要靠 <code>PIR</code></p><h4 id="ORAM技术"><a href="#ORAM技术" class="headerlink" title="ORAM技术"></a><strong><code>ORAM</code>技术</strong></h4><p>面向<strong>秘密数据库</strong>，其目标是在读写过程中向服务器<strong>隐藏用户的访问模式</strong>。这里，访问模式是指客户端向服务器发起访问所泄露的信息，包括操作是读还是写、操作的数据地址、操作的数据内容等</p><p><code>ORAM</code>与<code>PIR</code>的不同之处:</p><ul><li><code>PIR</code>只考虑保护客户端的<strong>查询意图</strong>，整个数据库的内容对服务器是可见的；</li><li><code>ORAM</code>则认为整个服务器的存储介质都是不安全的，因此要求数据是加密的，同时向服务器隐藏读写两种操作</li></ul><p><img src="https://s2.loli.net/2022/06/04/fAceUYRECOikFLb.png" alt="image-20220604202747198"></p><p>Y：一连串的操作</p><p>o：一个操作，包括读写模式，数据项(读时为空)，地址</p><p>A(Y)：访问模式，能够隐藏操作</p><h3 id="对称密文检索"><a href="#对称密文检索" class="headerlink" title="对称密文检索"></a>对称密文检索</h3><p><strong>在对称密文检索方案中，数据所有者和数据检索者为同一方。</strong></p><p>包括如下算法:</p><ul><li>Setup算法：该算法由<strong>数据所有者执行</strong>，<strong>生成用于加密数据和索引的密钥</strong></li><li>BuildIndex算法：该算法由<strong>数据所有者执行</strong>，根据数据内容建立索引，并将加密后的索引和数据本身上传到服务器</li><li>GenTrapdoor算法：该算法由<strong>数据所有者执行</strong>，根据检索条件生成相应的<strong>陷门</strong>（又称“搜索凭证”），然后将其发送给服务器</li><li>Search算法：该算法由<strong>服务器执行</strong>，将接收到的陷门和本地存储的密文索引作为输入，并进行协议所预设的密文查询计算，最后输出满足条件的密文结果</li></ul><h4 id="基于全文扫描的方案"><a href="#基于全文扫描的方案" class="headerlink" title="基于全文扫描的方案"></a>基于全文扫描的方案</h4><p>核心思想：</p><ol><li> 对文档进行<strong>分组加密</strong>，然后将分组加密结果与一个<strong>伪随机流进行异或</strong>得到最终用于检索的密文</li><li> 检索时，用户将<strong>检索关键词对应的陷门</strong>发送给服务器，服务器对所有密文依次使用陷门计算密文是否满足预设的条件，若满足则返回该文档</li></ol><p><img src="https://s2.loli.net/2022/06/04/4h8EjXsLq2rMy3V.png" alt="image-20220604212036339"></p><p>通过L(左边部分)与伪随机数经过两次伪随机函数计算后，生成与之异或的数据流。</p><p>两次密钥一个用于加密关键词，一个用于加密密文的左边部分L</p><p>缺点：在最坏的情况下，检索一篇文档的时间与该文档的长度呈线性关系，检索效率较低</p><h4 id="基于文档-关键词索引的密文检索方案"><a href="#基于文档-关键词索引的密文检索方案" class="headerlink" title="基于文档-关键词索引的密文检索方案"></a><strong>基于文档-关键词索引的密文检索方案</strong></h4><p>布隆过滤器：</p><p><img src="https://s2.loli.net/2022/06/04/sjLCtiP6KZTb2fn.png" alt="image-20220604212852545"></p><p>基于布隆过滤器的密文关键词检索方案：</p><p><img src="https://s2.loli.net/2022/06/04/oaCNQfS6iLmGYcA.png" alt="image-20220604213015614"></p><p>缺点：上述方案在检索判定时只需要计算若干次伪随机数，速度比基于全文扫描的方法提高很多。然而，由于布隆过滤器的特性，会有一定的概率返回不包含查询关键词的文档</p><h3 id="非对称密文检索"><a href="#非对称密文检索" class="headerlink" title="非对称密文检索"></a>非对称密文检索</h3><p>数据所有者可以是了解公钥的任意用户，而只有拥有私钥的用户可以生成检索陷门</p><p><img src="https://s2.loli.net/2022/06/04/HBXP9DKcrWoQJxN.png" alt="image-20220604214318585"></p><h2 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h2><p>基于口令的身份认证技术</p><p>口令攻击方式：</p><ol><li>网络监听</li><li>数据库入侵</li><li>编程漏洞</li><li>暴力攻击</li></ol><p>带杂凑函数(hash)和盐(salt)的口令认证</p><p>hash函数的作用：防止口令文件直接泄露用户的口令</p><p>加盐(salt)的作用：增加字典攻击的难度，彩虹表攻击(rainbow table)</p><p>远程身份认证技术</p><p>风险及对策：</p><ol><li>窃听：数据加密，密码杂凑算法</li><li>重放攻击：用随机数(Nonce)、时间戳，挑战-应答协议</li><li>伪造消息：数字签名、消息鉴别码</li><li>中间人攻击：数字签名</li></ol><p><img src="https://s2.loli.net/2022/06/04/V3PLQSJxayTm7wj.png" alt="image-20220604122724227"></p><p>先请求一个随机数，然后再携带随机数请求保证每次的 <code>Auth_Infor</code> 不一样，防止攻击者使用旧的身份信息发出请求，实施重放攻击</p><p>复杂的身份认证方式会导致：</p><ol><li> 增加了用户疲劳</li><li> 降低了客户满意度</li><li> 减低企业服务竞争力</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDSC: 一个事件驱动的智能契约平台</title>
    <link href="/2022/06/01/EDSC-%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%99%BA%E8%83%BD%E5%A5%91%E7%BA%A6%E5%B9%B3%E5%8F%B0/"/>
    <url>/2022/06/01/EDSC-%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%99%BA%E8%83%BD%E5%A5%91%E7%BA%A6%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="EDSC：一个事件驱动的智能契约平台"><a href="#EDSC：一个事件驱动的智能契约平台" class="headerlink" title="EDSC：一个事件驱动的智能契约平台"></a>EDSC：一个事件驱动的智能契约平台</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>一种基于事件驱动执行模型的新型智能契约平台设计，而不是传统的事务驱动执行模型。事件驱动的体系结构模式是一种简单而强大的分布式体系结构模式，已被证明可以产生高度可伸缩性和适应性强的应用程序。该模型通过允许参与者发布发生事件的通知，以及订阅感兴趣的事件，并被系统异步通知发生事件的通知，从而实现通信。</p><p>事务？一连串的原子动作，在区块链中一次交易或创建一个智能合约都可以看成一个事务</p><p>传统的事务驱动执行模型？ 当区块链中发生了你想要了解的事情的时候，他不会主动去通知你发生了什么变化，或是产生了什么新的数据，需要你自己去获取。怎么获取呢？需要你主动与之形成一次交易，完成信息的传递，他把信息给你放在data 字段中。</p><h2 id="提出的背景"><a href="#提出的背景" class="headerlink" title="提出的背景"></a>提出的背景</h2><p>原文：智能契约生态系统的进化已经被各种障碍所阻碍，主要是在事务性能（例如，延迟、吞吐量）和可伸缩性领域。尽管有项目试图通过分片和执行并行化解决方案来解决问题 ，但许多复杂的设计挑战仍未得到实际解决。随着最近去中心化金融服务(DeFi)的前所未有的增长，越来越多的智能合约正在与甲骨文网络接口，以获取真实世界的信息。由于这种接口是通过大多数平台上的双向事务完成的，这一趋势必然会进一步加重已经拥挤的系统。</p><p>一句话讲，就是网络负担加重，性能有大问题。</p><p>什么是可伸缩性？可伸缩性是指在一系列功能中增加计算过程的能力。对于区块链来说，最常被讨论的伸缩挑战是增加事务吞吐量，或者在区块链上执行的事务数量。</p><p>为什么性能不好？ 这不就给区块链中添加了很多没用的交易了吗？区块链在一定时间段内能够处理的事务量是有限的，会增加区块链的负担。</p><h2 id="主要解决的问题"><a href="#主要解决的问题" class="headerlink" title="主要解决的问题"></a>主要解决的问题</h2><p>智能合约生态系统的可伸缩性和性能挑战</p><h2 id="有什么贡献"><a href="#有什么贡献" class="headerlink" title="有什么贡献"></a>有什么贡献</h2><ol><li><p>提出了一个具有本地支持实时事件处理的事件驱动的智能契约平台 </p><p>为什么本地支持？当区块链中某事件发生时，你需要等待智能合约向你发起一项交易，你查询自己的交易信息从而得知这一事件的发生。现在相当于你所在的客户端在本地监听区块链时，有来自自己订阅的事件信号，那么就启动相对应的处理程序。</p></li><li><p>提供了一个以以太坊为参考目标的基于事件的系统的设计。</p><p>下面的所有都是基于以太坊的假设即解决措施</p></li><li><p>描述了该设计在潜在用例中的优势，并对其安全性方面进行了评论。</p></li><li><p>使用<code>Golang</code>以太坊客户端进行了一个实现，并进行了实验，性能建模结果显示 ，事件触发的智能契约的总延迟平均减少了2.2到4.6倍，这证明了它在支持需要基于事件及时执行的契约方面的有效性 。</p><p>原来的延迟包括事务的处理时间，交易执行过程等</p><p>而现在只需要事件发生时，你监听广播就行了</p></li></ol><h2 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h2><ol><li><p>IBM 提供的商业实现和服务，使用Java微服务层和使用开放自由层侦听区块链中的事件 。区块链提供了流程的完整性，而Java微服务层和开放自由层则确保了它可以有基于事件的事务。</p><p>缺陷：依赖于Java微服务层和开放自由层。除了实现层之外，它不对任何基于事件的事务使用智能契约。</p></li><li><p>Amazon 使用超分类帐结构和以太坊作为底层，允许三种不同类型的事件与区块链网络交互（块事件，交易事件，链码事件）</p><p>缺陷：依赖于 <code>AWSFargate</code> 作为事件侦听器，又依赖于<code>lambdas</code>对亚马逊简单队列服务进行处理</p></li><li><p>事件管理员 — 去中心化的事件驱动代理，可以与类似以太坊的区块链网络交互并传递交易，消除了类似于 IBM 和 Amazon 所使用的辅助服务的使用。它允许用户创建一个代理智能契约，描述契约中的事件。区块链网络中的任何人都可以通过调用代理合同并显示相关事件已被记录到区块链日志中来触发保留事务的释放。</p></li><li><p>以太坊闹钟 | <code>Chao and Palanisamy</code> — 允许用户在以太 坊网络上部署一个具有未来时间限制的请求契约。</p><p>缺陷：只支持一种类型的事件，即一个预定义的时间框架的到来</p></li></ol><p>这些解决方案都是为了解决事务方面的问题，主要是为了让你不用主动去查，而是当发生变化时，主动来通知你。</p><p>但是都有相应的缺陷，要么需要依赖于其他的第三方设施，在区块链和你所在的客户端之间加了一层。要么是只支持特定类型的事件通知，在一定的领域可以得到很好的应用，但没有普适性。</p><h2 id="EDSC"><a href="#EDSC" class="headerlink" title="EDSC"></a>EDSC</h2><p>来看看 EDSC 是怎么解决这个问题的！？</p><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ol><li>事件定义：系统中的任何外部帐户或智能合约都能够在系统中定义/注册新的和唯一的事件类型。这类似于在面向对象的编程范式中定义一个类。</li><li>事件订阅：系统中的任何智能契约都能够订阅或取消订阅系统中已经定义的特定事件类型。</li><li>事件发布：任何智能契约都能够发布已经在系统中定义的事件。</li></ol><h3 id="特定功能"><a href="#特定功能" class="headerlink" title="特定功能"></a>特定功能</h3><ol><li><p>事件定义维护：事件模板将永久保存在系统中。</p></li><li><p>订阅信息维护：订阅信息也会始终不变地保存在系统中。</p></li><li><p>事件匹配：每次处理一个已发布的事件时，系统都会确定订阅该特定事件的所有智能契约。</p></li><li><p>事件排队：基于事件匹配，系统排队所有匹配订阅的智能合约排队执行。</p><p>按照愿意支付的gas费用排序</p></li><li><p>空间解耦：发布和订阅的智能合约不需要相互了解，因为它们不需要相互地址通信</p><p>这里就是非交易类型传递信息的结果，发布或订阅事件，独立完成</p></li><li><p>时间解耦：没有规定发布者或订阅者可以在任何时间限制内运行</p><p>发布者不必在事件发生后立即依次通过交易通知，只需触发事件即可</p><p>订阅者不必定时查询交易，只等待事件触发即可</p></li><li><p>执行流解耦：固有的异步通信将执行流与合同间通信解耦</p><p>之前的机制要求事件发生后，事务处理一旦完成就立马与客户端进行一次交易，而客户端需立即接受，双方是同步执行的，从而传递消息。现在两者是异步发生的，不一定会连续发生，触发事件在事务处理周期内都可以进行，等待事件触发可能一直在进行。</p></li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li><p>更低的费用：交易成本，即现在是将事件放到链上的成本，由所有订阅者共同分担。</p><p>为什么呢？当通过交易的方式进行时，每通知一个地址，都会形成一笔交易，会消耗对应的gas费用，会由交易发起者一人承担。但是若使用这种方式的话，只会花费将事件广播到区块链上的费用，这个费用是所有订阅者均摊的。</p></li><li><p>改进的安全性：事件是异步发布的，而不等待订阅者合同运行。</p></li><li><p>更少的网络阻塞：有多个智能合同订阅一个事件意味着较少的网络使用，而不是智能合同要求在每次需要执行或与 Oracle提供商接口时都广播事务。</p><p>更少的交易量。</p></li><li><p>更好的可伸缩性：基于所提出的基本设计的事件驱动系统可以更好地使用并行处理和分片解决方案来实现可伸缩性。</p><p>减少了区块链上的事务量</p></li></ol><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="事件定义的实现"><a href="#事件定义的实现" class="headerlink" title="事件定义的实现"></a>事件定义的实现</h4><p>在以太坊上下文中，这可以通过要求所有节点在本地维护全局事件定义数据来实现。然后，可以在区块链上引用此事件定义数据以实现不变性。这类似于当前的以太坊设计维护系统状态的方式。换句话说，事件定义将需要添加到以太坊系统中。</p><p>—— 每个节点都会存储有所有的事件定义</p><p>系统中的任何智能合约或外部帐户都有能力定义一个新的事件类型。这可以通过发布在系统中已经预定义的特殊类型的事件来实现。特殊事件的有效负载包括对新事件的模板的定义。在处理此事件时，网络中的任何节点都会将事件定义添加到其本地事件定义数据库中。</p><p>—— 自己也可以定义事件，但需要广播发布，更新所有节点</p><p>一个新的事件定义包含的属性：</p><ul><li>唯一的事件id： 用于区分各种事件。可以是该事件代码的Hash值</li><li>变量组：当事件发生需要发布与记录的变量值</li><li>描述：该事件的作用或目的的描述</li></ul><h4 id="事件订阅的实现"><a href="#事件订阅的实现" class="headerlink" title="事件订阅的实现"></a>事件订阅的实现</h4><p>事件订阅也会将订阅信息存储在区块链中，保证本地知道订阅了哪些事件。每新增加对某个事件的订阅，都会形成下方的数据结构，并挂载到区块链中该事件的订阅队列中。实际上，事件定义和订阅信息可以组合成一个序列，可以在链上引用</p><p>—— 也就是说可以将该事件的定义以及它所对应的订阅信息放在一起，除了自己的地址外，外需指定：</p><ul><li>事件id</li><li>gasPrice：自己愿意为接受这一事件消息付出的gas费，事件排队就是依据此值大小</li><li>gasLimit： 自己愿意支付的最高值，免得自己的money全耗光了</li><li>发布者id：自己规定是接受来自哪个发布者的事件消息，免得接收了不属于自己关注的人的同种事件消息。</li><li>块速率： 每多少个块接受一次订阅，有的事件太过于频繁，白浪费money。你可以100个块接受一次订阅，100*10=1000分钟</li><li>事件发生率：每接受多少次事件，执行一次订阅。同样为了避免频率过高</li><li>自定义逻辑判断</li></ul><p>订阅事件允许对响应在网络中发布的特定事件执行智能契约。每当该订阅事件发生时，用户智能契约的默认回调函数，并且事件的唯一标识符和有效负载作为参数传递。(id + 变量组)</p><h4 id="事件发布的实现"><a href="#事件发布的实现" class="headerlink" title="事件发布的实现"></a>事件发布的实现</h4><ol><li>可以在一次交易中发生</li><li>可以是采用系统外调用的方式，使用该事件的操作码，就像以太坊的call操作码一样</li><li>可以由系统本身发出</li></ol><p>事件体包含以下内容：</p><ul><li>事件id</li><li>发布者id</li><li>有效载荷：也有是变量组，但是现在是所对应的具体值</li><li>gas值：每一个订阅者应当支付的费用，因为现在这个事件体是由发布者发出的，费用是他代扣的，现在要从订阅者那里收回，这是所有接受订阅的均摊的，因此订阅的数量越多，费用就越低。当然，当这一平均费用超过了某些订阅者的 gasLimit 值，也不予订阅。</li></ul><h4 id="gas费用的区别"><a href="#gas费用的区别" class="headerlink" title="gas费用的区别"></a>gas费用的区别</h4><p>在基于事务的系统中，生成交易的实体必须支付与由于交易而执行的任何智能合同代码的计算、存储和其他成本相关联的天然气费用。这包括发送事务的合同代码以及接收方代码调用或调用的合同。</p><p><img src="https://s2.loli.net/2022/05/31/kyLRhcjX98HvpWD.png" alt="image-20220531203305098"></p><p>明显的，通过交易所花费的gas费用，远远会超过发布者一次发布触发事件的均摊花费。</p><h4 id="与事务驱动的区别"><a href="#与事务驱动的区别" class="headerlink" title="与事务驱动的区别"></a>与事务驱动的区别</h4><p><img src="https://s2.loli.net/2022/05/31/NdvRIO5tPrx6ufc.png" alt="image-20220531205630584"></p><h4 id="执行过程的独立性和原子性"><a href="#执行过程的独立性和原子性" class="headerlink" title="执行过程的独立性和原子性"></a>执行过程的独立性和原子性</h4><p>执行过程的独立性，源于 空间解耦，发布与收听事件都可以独立完成，这使得智能合约之间没有了限制，智能合约执行时不会依赖于其他任何的智能合约，因此才保障了独立性。</p><p>而为了执行过程的原子性，得益于 时间解耦/执行流解耦 ， 当一个智能合约在执行的过程中，可以先暂时的关闭事件收听，因为这是异步的，所以完全可以在当前事务处理完之后再接收事件触发。</p><h4 id="订阅的执行和选择"><a href="#订阅的执行和选择" class="headerlink" title="订阅的执行和选择"></a>订阅的执行和选择</h4><p>订阅的通知顺序也需要决定，这就由于 事件匹配/事件排队 决定</p><p>当智能合约触发事件时，会在相应事件的订阅队列中找到所有的能够执行的订阅—— 正在运行的智能合约的订阅或者gas费用不够的订阅不会被选择。将这些订阅放到缓冲区中，他们的位置由他们愿意支付的gas费用大小决定，gas费相同的订阅者按订阅的先后顺序排列。当通知时即以此顺序通知。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ol><li><p>防止智能间合约通信相关的漏洞，包括拒绝服务攻击</p><p>智能合约之间的通信完全靠事件的订阅与发布，相互之间不直接通信，连彼此的地址对于智能合约本身也是不知道的，因为事件信息和订阅信息都是存储在区块链上的。</p><p>拒绝服务攻击：攻击者想通过污染缓冲区的方式，让缓冲区中充满垃圾信息，让系统崩溃。但是因为事件发布者需要首先承担发布费用，这些费用是后续才从订阅者那里收回的，若使用此类攻击，其高额的花费它本身也无法承担。而且订阅者还可以自己设置接收事件的频率，包括块速率和事件发生率，也可以防范。</p></li><li><p>恶意的市场剥削和相关的欺骗行为</p><p>例如，当一个节点观察到一个可以提取财务值的事件更新时，该节点可以发送一个注册到该事件的快捷方式消息，或更新其事件注册，以提高其在事件缓冲区中的优先级 。类似地，当挖掘者检测到值可提取的机会时，可能会激励矿工直接插入新的事件订阅或修改现有订阅。由于矿工控制事件处理，矿工可以利用这个位置来排序从特定时期的事件订阅生成的事件或事务，以提取除块奖励和事务费用之外的价值。</p><p>在EDSC框架中，全局事件订阅状态可以阻止这类攻击 。事件订阅状态受Merkle散列树保护，根散列作为块头的一 部分包含。通过链上事务更新启动，并使用底层区块链共识机制进行确认。EDSC系统强制执行对全局事件订阅状态的更改有效的最小延迟（最小块延迟）。—— 也就是说EDSC的事件信息和订阅信息都是存储在区块链上的，后面中途所有没有经过共识承认的更改操作，Merkle散列头发生了变化，没有经过其他节点的承认的块将被拒绝。</p></li><li><p>系统中的某些坏节点可以观察正在发布的事件，并复制有效载荷，并以较低的订阅费发布相同的事件。这种冒充的方式可以使用 ChainLink 中的一种承诺方案解决。</p></li></ol><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p>原论文在 👉 <a href="./EDSC.pdf">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDSC</tag>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx总结</title>
    <link href="/2022/05/17/Nginx%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/17/Nginx%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="https://nginx.org/en/download.html"><code>Nginx官网</code></a>下载，并上传至服务器 /root 路径下, 以下是 1.21.6版本</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tar zxvf nginx<span class="hljs-number">-1.21</span><span class="hljs-number">.6</span>.tar.gz <span class="hljs-comment">// 解压</span><br>cd nginx<span class="hljs-number">-1.21</span><span class="hljs-number">.6</span><br><br><span class="hljs-comment">// 检查: 如果缺少依赖, 先安装依赖, 再次检查</span><br>.<span class="hljs-regexp">/configure --prefix=/</span>usr<span class="hljs-regexp">/local/</span>nginx --with-http_stub_status_module --with-http_ssl_module<br><br><span class="hljs-comment">// 依赖</span><br>yum install -y gcc<br>yum install -y pcre pcre-devel<br>yum install -y zlib zlib-devel<br><br><span class="hljs-comment">// 编译</span><br>make<br>make install<br><br><span class="hljs-comment">// 在 usr/local/nginx/sbin 目录下</span><br>.<span class="hljs-regexp">/nginx /</span>/ 启动<br>.<span class="hljs-regexp">/nginx -s stop /</span>/ 快速停止<br>.<span class="hljs-regexp">/nginx -s quit /</span>/ 完成已经接受的请求后退出<br>.<span class="hljs-regexp">/nginx -s reload /</span>/ 重新加载配置文件<br><br><span class="hljs-comment">// 安装成系统文件, 即可用 systemctl 控制</span><br>vi <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/nginx.service<br><span class="hljs-comment">// 填写以下:</span><br>[Unit]<br>Description=nginx - web server<br>After=network.target remote-fs.target nss-lookup.target<br><br>[Service]<br>Type=forking<br>PIDFile=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>logs/nginx.pid<br>ExecStartPre=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/nginx -t -c /</span>usr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf<br>ExecStart=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/nginx -c /</span>usr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf<br>ExecReload=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s reload<br>ExecStop=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s stop<br>ExecQuit=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s quit<br>PrivateTmp=<span class="hljs-literal">true</span><br><br>[Install]<br>WantedBy=multi-user.target<br><br><span class="hljs-comment">// 重新加载系统服务</span><br>systemctl daemon-reload<br></code></pre></td></tr></table></figure><h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 工作进程数</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br><span class="hljs-comment"># 一个进程可以创建的连接数</span><br><span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><span class="hljs-comment"># include 引用该目录的其他文件</span><br><span class="hljs-comment"># 当服务器给浏览器传输文件时, 根据 mime.types 给定的方式来解析文件</span><br><span class="hljs-comment"># 当不存在于 mime.types 中的文件类型时, 默认按 application/octet-stream 解析</span><br><span class="hljs-comment"># 需要手动在 mime.tupes 中添加自己的需要的文件类型的解析方式</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br><span class="hljs-comment"># 当向服务器请求文件时, nginx 不读取文件, 直接通过 sendfile 方式推送给网络接口</span><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br><span class="hljs-comment"># 虚拟主机 vhost</span><br>    <span class="hljs-comment"># 一个 server 对应一个主机, 相互之间不干扰</span><br>    <span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># 监听的端口号</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost; <span class="hljs-comment"># 域名、主机名</span><br><br><span class="hljs-comment"># 访问 &#x27;/&#x27; 的路由</span><br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   html; <span class="hljs-comment"># nginx根目录下的路径目录</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm; <span class="hljs-comment"># 入口文件</span><br>        &#125;<br><br><span class="hljs-comment"># 服务器错误 错误码 重定向地址</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-comment"># 访问 &#x27;/50x.html&#x27; 的路由</span><br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h2><p>**将域名解析到IP：主机记录为 <code>@</code> **</p><p>**将域名泛解析到IP：主机记录为 <code>*</code> **</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 在 nginx 根目录(/usr/local/nginx)新建存放各站点文件的 www 文件</span><br>mkdir www<br><span class="hljs-comment">// 创建各站点文件文件夹并放入相应的资源</span><br><span class="hljs-comment">// 例 :</span><br>mkdir ROOT &amp;&amp; mkdir blog &amp;&amp; mkdir music<br><br><span class="hljs-comment">// 在配置文件中：</span><br>    server &#123;<br>        listen       <span class="hljs-number">80</span>;<br>        server_name  bigzcy.club; <span class="hljs-meta"># 域名</span><br>        <br>        <span class="hljs-keyword">location</span> / &#123;<br>            root   www/ROOT; <span class="hljs-meta"># 指向对应站点的目录</span><br>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>        &#125;<br><br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        <span class="hljs-keyword">location</span> = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br><br>    server &#123;<br>        listen       <span class="hljs-number">80</span>;<br>        server_name  music.bigzcy.club; <span class="hljs-meta"># 配置二级域名</span><br>        <br>        <span class="hljs-keyword">location</span> / &#123;<br>            root   www/music; <span class="hljs-meta"># 指向对应站点的目录</span><br>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>        &#125;<br><br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        <span class="hljs-keyword">location</span> = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br><br>    server &#123;<br>        listen       <span class="hljs-number">80</span>;<br>        server_name  blog.bigzcy.club;<br><br>        <span class="hljs-keyword">location</span> / &#123;<br>            root   www/blog;<br>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>        &#125;<br><br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        <span class="hljs-keyword">location</span> = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 重新加载配置文件</span><br>systemctl reload nginx<br></code></pre></td></tr></table></figure><h2 id="泛解析"><a href="#泛解析" class="headerlink" title="泛解析"></a>泛解析</h2><p>出上往下，根据 <code>server_name</code> 来配置各域名访问的站点</p><p>当所有站点都没有匹配上, 默认指向第一个站点，所以第一个站点一般会是主站点</p><ol><li><p>完整匹配</p><p>支持一个 server_name 配置多个域名</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">server_name blog1<span class="hljs-selector-class">.bigzcy</span><span class="hljs-selector-class">.club</span> blog2<span class="hljs-selector-class">.bigzcy</span>.club<br></code></pre></td></tr></table></figure></li><li><p>通配符匹配</p><p>当匹配到此处时，通配所有该域名或二级域名都指向该网站，此方式也可配置主站点</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">server_name</span> <span class="hljs-regexp">*.bigzcy.club</span><br></code></pre></td></tr></table></figure></li><li><p>通配符结束匹配</p><p>当一个站点需要多个一级域名匹配时</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">server_name</span> <span class="hljs-regexp">www.bigzcy.*</span><br></code></pre></td></tr></table></figure></li><li><p>正则匹配</p><p>使用正则表达式的方式使站点匹配更加灵活，以<code>~</code>开始</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 表示二级域名为数字的站点, 如: 123.bigzcy.club</span><br>server_name ~^\d+\<span class="hljs-string">.bigzcy</span>\<span class="hljs-string">.club</span>$;<br></code></pre></td></tr></table></figure></li></ol><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>当请求此服务器时，该请求会被转发到 proxy_pass 所对应的域名或IP下的服务器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <br>        <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-comment"># 代理服务器 域名或IP(完整)</span><br>        <span class="hljs-comment"># 当存在 proxy_pass 时, root | index 等配置失效</span><br>            <span class="hljs-attribute">proxy_pass</span> http://bigzcy.club;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>负载均衡：当代理多个服务器时，需要轮询式转发请求</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 定义一组负载服务器, httpds 作为标识, 相当于别名, 可任取</span><br><span class="hljs-attribute">upstream</span> httpds &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">192.168.216.128:80</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">192.168.216.129:80</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <br>        <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-comment"># proxy_pass 使用到 httpds ,将请求以此转发到 upstream 中各负载服务器</span><br>            <span class="hljs-attribute">proxy_pass</span> http://httpds;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>upstream</code> 用于负载均衡，用法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">weight</span> <span class="hljs-comment"># 按权重分配请求转发比例(weight=8)</span><br>down   <span class="hljs-comment"># 该服务器不再接收转发</span><br>backup <span class="hljs-comment"># 当其他所有服务器均不可用时，启用该服务器(备用机)</span><br><br>upstream httpds &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">192.168.216.128:80</span> [参数加在这里];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>将静态资源目录前移至 <code>Nginx</code> 目录，从而避免了请求时的转发过程</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 比如：</span><br><span class="hljs-comment"># express 项目时, 可以将静态资源文件从 express_static 的 public 目录转移至 nginx 中</span><br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <br>        <span class="hljs-attribute">location</span> /api &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;<br>        &#125;<br>        <br>        <span class="hljs-attribute">localhost</span> ~*/(js|img|css|html)$ &#123;<br>        <span class="hljs-attribute">root</span> html;<br>        <span class="hljs-attribute">index</span> index.html index.htm;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="URL-Rewrite"><a href="#URL-Rewrite" class="headerlink" title="URL  Rewrite"></a>URL  Rewrite</h2><p>将前端请求的URL重写后转发给后端服务器，用以隐蔽请求参数</p><p>用法： rewrite    &lt; 正则 &gt;    &lt; 替换内容 &gt;    &lt; 标志位 &gt; </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <br>        <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-comment"># rewrite 是对 uri 的重写</span><br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/([0-9]+).html$</span> /page/<span class="hljs-variable">$1</span> <span class="hljs-literal">break</span>;<br>        <span class="hljs-comment"># 常用 flag 位： break(匹配成功后停止匹配) redirect(将url重定向为重写后的url)</span><br>            <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p>防止其他网站非法引用本站点的资源</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;<br>   <span class="hljs-attribute">valid_referers</span> <span class="hljs-literal">none</span> server_names;<br>   <span class="hljs-comment"># 当不包含 refer 字段或是 refer 指向指定的服务器时, 支持访问</span><br>   <span class="hljs-comment"># 否则返回 403 错误</span><br>   <span class="hljs-attribute">if</span> ($valid_referer)&#123;<br>      <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>   &#125;<br>            <span class="hljs-attribute">root</span>   www/blog;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br></code></pre></td></tr></table></figure><p>处理方式：</p><ol><li>返回错误码： 通过配置错误页面的方式展示</li><li>返回 <code>uri</code> ： 配置相应 <code>uri</code>的页面展示</li><li><code>rewrite uri</code> ： 使用其他资源代替</li></ol><h2 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h2><p>nginx 高可用配置，nginx 一主服务器，一备用服务器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 安装</span><br>yum install -y keepalived<br><br><span class="hljs-comment">// 配置</span><br>vi /etc/keepalived/keepalived.conf<br><br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>   router_id nginx_master # 不同服务器 router_id 需要配置不同 <br>&#125;<br>vrrp_instance VI_1 &#123;<br>    state MASTER # 名称, 可任取<br>    <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ens33</span><br>    <span class="hljs-symbol">virtual_router_id</span> <span class="hljs-symbol">51</span><br>    <span class="hljs-symbol">priority</span> <span class="hljs-symbol">100</span> # 优先级, 以此来表示主从关系<br>    <span class="hljs-symbol">advert_int</span> <span class="hljs-symbol">1</span><br>    <span class="hljs-symbol">authentication</span> &#123;<br>        auth_type PASS<br>        auth_pass <span class="hljs-number">1111</span><br>    &#125;<br>    virtual_ipaddress &#123;<br>    # 虚拟IP, 访问时用此IP, 并在主从服务器上选择服务(主服务器宕机,从服务器得到此虚拟IP)<br>        <span class="hljs-number">192.168</span><span class="hljs-number">.216</span><span class="hljs-number">.100</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 启用</span><br>systemctl start keepalived<br></code></pre></td></tr></table></figure><h2 id="Https-配置"><a href="#Https-配置" class="headerlink" title="Https 配置"></a>Https 配置</h2><p>将证书解压上传至服务器的 <code>/usr/local/nginx/conf</code> 目录下，并配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    # http 与 https 共存<br>    <span class="hljs-keyword">server</span> &#123;<br>        <span class="hljs-keyword">listen</span>       <span class="hljs-number">80</span>;<br>       <span class="hljs-keyword">listen</span>       <span class="hljs-number">443</span> ssl;<br>   server_name  localhost;<br><br>        <span class="hljs-keyword">location</span> / &#123;<br>            root   html;<br>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>        &#125;<br><br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        <span class="hljs-keyword">location</span> = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br><br>   ssl_certificate <span class="hljs-number">7546233</span>_www.bigzcy.club.pem;<br>   ssl_certificate_key <span class="hljs-number">7546233</span>_www.bigzcy.club.key;<br>    &#125;<br>    <br>    # 仅支持 https, http 自动重定向<br>    <span class="hljs-keyword">server</span> &#123;<br>       <span class="hljs-keyword">listen</span>       <span class="hljs-number">443</span> ssl;<br>   server_name  localhost;<br><br>        <span class="hljs-keyword">location</span> / &#123;<br>            root   html;<br>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br>        &#125;<br>        <br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        <span class="hljs-keyword">location</span> = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br><br>   ssl_certificate <span class="hljs-number">7546233</span>_www.bigzcy.club.pem;<br>   ssl_certificate_key <span class="hljs-number">7546233</span>_www.bigzcy.club.key;<br>    &#125;<br>    <br>    <span class="hljs-keyword">server</span> &#123;<br>    <span class="hljs-keyword">listen</span>   <span class="hljs-number">80</span>;<br>    server_name www.bigzcy.club bigzcy.club;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">301</span> https://$server_name$<span class="java">request_uri;</span><br><span class="java">    &#125;</span><br><span class="java"></span><br><span class="java"><span class="hljs-comment">// 重启即生效</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>个人笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
